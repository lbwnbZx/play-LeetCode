class Solution {
   public List<List<String>> partition(String s) {
    boolean[][] dp = new boolean[s.length()][s.length()];
    int length = s.length();
    for (int len = 1; len <= length; len++) {
        for (int i = 0; i <= s.length() - len; i++) {
            dp[i][i + len - 1] = s.charAt(i) == s.charAt(i + len - 1) && (len < 3 || dp[i + 1][i + len - 2]);
        }
    }
    List<List<String>> ans = new ArrayList<>();
    partitionHelper(s, 0, dp, new ArrayList<>(), ans);
    return ans;
}

private void partitionHelper(String s, int start, boolean[][] dp, List<String> temp, List<List<String>> res) {
    //到了空串就加到最终的结果中
    if (start == s.length()) {
        res.add(new ArrayList<>(temp));
    }
    //在不同位置切割
    for (int i = start; i < s.length(); i++) {
        //如果是回文串就加到结果中
        if (dp[start][i]) {
            String left = s.substring(start, i + 1);
            temp.add(left);
            partitionHelper(s, i + 1, dp, temp, res);
            temp.remove(temp.size() - 1);
        }

    }
}
}
